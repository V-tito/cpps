Пилим кастомные типы, чтобы record работал
Как с тестами закончу:
    Что такое прототипы и зачем они нужны?
    Нужен ли case отдельно или ir переводит его в if (по идее нужен)
    разобраться с массивами размера 0
    размещение массивов на регистрах как таковое гдето используется вообще?
    Получить одобрение на замену передачи массива в функцию на передачу указателя по умолчанию (проверить спецификацию сосала, мб там уже так, это вроде логично, учитывая неизменяемость переменных. с другой стороны, неизменяемость массива означает неизменяемость формы, а не размерностей и не элементов => все-таки передача указателей - это скорее нет, чем да)
    присваивать выходным портам массивов указатель как value по умолчанию, подумать, какие подводные могут быть (переменные неизменяемые => копия не нужна никогда)
    Разобраться с массивами в sisal и удостовериться в соответствии спецификации!
    оптимизатор: добавлять в IR метаданные с max размерами массива (max исп.элемент), если те известны при компиляции (получить одобрение)?
    зачем нужна операция идентичности? чтобы понимать, как обрабатывать её в ir
    именование портов влияет на какую-то внутреннюю логику или нужно только для читаемости выводимого кода?
    добавить проход, который удаляет let? или внутренняя оптимизация llvm с этим справится?
    а main может возвращать указатель на массив?
    в каких ситуациях возникают ограничения на alloca и как их избегать, если нужно разместить массив неизвестной длины?
    ~=?
Возможное:
    сделать запуск вместо байткода, тогда:
        надо ли запускать через cfunctype?
        надо ли запускать через jit?
        как сделать автоопределение типа функции?
        в bind-е автопоиск main-а и автозапуск его же
    вообще по идее целевая машина будет отличаться от хоста, следовательно, нужно выводить ir и пропускать его через llc, следовательно, вероятно, понадобится обертка на llc и НЕ понадобится llvmlite jit-байткод
    Отдельный класс (и мб файл) для execution_engine и в принципе исполнения программы
    возможность задавать целевую машину, в т.ч. отдельную от хоста (тогда возвращать байткод (или в llc передавать))
    llvmlite вообще умеет в байткод для несовместимой с хостом архитектуры?
    возможность включать оптимизацию
    как скомпилировать программу с несколькими файлами?
    
